\documentclass[12pt]{diazessay}

\usepackage{bashful}
\usepackage{hyperref}

%----------------------------------------------------------------------------------------
%	Comment this out if you do not have `texcount` installed on your $PATH
%----------------------------------------------------------------------------------------
%\bash
%command -v texcount &> /dev/null && texcount -sum -1 csci-724-paper.tex
%\END

%Shorthand formatting commands
\newcommand{\F}[1]{$\quad$\texttt{#1}}
\newcommand{\A}{$\alpha$}
\newcommand{\B}{$\beta$}
\newcommand{\Bool   }{\texttt{Bool}}
\newcommand{\Nat    }{\texttt{Natural}}
\newcommand{\Integer}{\texttt{Integer}}
\newcommand{\Double }{\texttt{Double}}
\newcommand{\List   }{\texttt{List}}
\newcommand{\Type   }{\texttt{Type}}

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\title{\texttt{\huge{Fuzzing NetHack for Fun and Prestige} \\\vspace{-0.65cm} {\large A Hunter College CSCI-795 Project Proposal}\\\normalsize\url{https://github.com/recursion-ninja/Superion-YAML}}} % Title and subtitle

\author{\texttt{{\Huge Team:}\\\vspace*{-0.5em} 
		Sabina Bhuiyan \\\vspace*{-0.5em} 
		Kyoungwoo Lee \\\vspace*{-0.5em}
		Chuanyao Lin \\\vspace*{-0.25em}
		Alex Washburn}} % Author and institution

\date{\texttt{\today}} % Date, use \date{} for no date

\pagestyle{empty}
%----------------------------------------------------------------------------------------

\begin{document}

\maketitle % Print the title section

\vspace{-1cm}
\section*{Project Proposal}

For our project, we propose to explore the efficiency of fuzzing programs which take YAML as input.
Fuzzing is a venerable application security testing technique developed in the late '80s \cite{Barton1988} and published in 1990 \cite{Miller1990}.
Fuzzing tools generate input which is directed towards the program and detect if the input was accepted or caused unexpected behavior.
Unexpected behavior can take many forms including, infinite loops, stack smashing, buffer overflows, arithmetic overflows or errors, and illegal program states.
Unexpected behavior that we are looking for include runtime exceptions, infinite loops, and illegal states.
Fuzzing tools can take many forms \cite{ModelBasedFuzzing}\cite{GrammarBasedFuzzing}\cite{ProtocolBasedFuzzing} and modify program input in many ways.
Different fuzzing tools tend to specialize in a few related forms of input\cite{InputDiversity} manipulation.

AFL relies on genetic algorithm techniques\cite{InputMutationAlgorithm} to mutate acceptable input into input triggering unexpected behavior. Using the generic AFL approach, inputs would be mutated randomly, and an initially valid YAML input would quickly become invalid.
This is a longstanding problem in the art of fuzzing and is the subject of emerging research
Generating consistently well structured inputs via ``grammar-aware'' mutations is a technique one such technique for addressing the problem of structured inputs.

Superion \cite{superion} is an open source fuzzing tool created by modifying and extending AFL.
Superion currently generates valid JavaScript and XML inputs by taking a context free grammar and an input seed, then performing a series of ``grammar-aware'' mutations to create a sequence of validly structured inputs.
The results of Superion show a great increase in fuzzing efficacy when targeting programs which expect structured input. 

The goal of this project is extend the capabilities of Superion to support generating structured YAML inputs.
We will compare the efficacy of our extended Superion to generic AFL.
If the discovered defect(s) are notable, we will draft a manuscript and publish in an appropriate journal after the semester ends.

% \clearpage

\section*{Motivation}

Fuzzing is an automated technique generating random data as input to a software system and trying to find out a vulnerability.
However, the random input generated by the fuzzing tools should be common enough to fit in the interpreter that only accept a semantically valid program. On the other hand, the fuzzed input also need to be uncommon enough to trigger exceptional behavior.
In order to be effective, we've found a fuzzing tool "Superion"\cite{superion},which proposed a grammar-aware coverage-based coverage-based greybox fuzzing approach to fuzz programs that process structured inputs.
Since the YAML is a famous configuration as a human friendly data serialization language for all programming languages, so we're thinking of improving the fuzzing tool to generate YAML based on the concept of the grammar-aware trimming strategy.
After taking the cybersecurity course and learning about the fuzzing software, we hope to see whether these tools might can be utilized as an automated method of finding out these software exploits.


\section*{Approach}

We will extend the functionality of Superion to generate mutable, grammar-aware YAML output.
The YAML output can be used for a variety of fuzzing techniques.
The most notable is as a configuration file fuzzer, as many programs use YAML as the input language for configuration files.
However, we can also fuzz YAML processing libraries directly, as the output should be accepted by the parsing phase of the libraries, allowing it to effective test the library's internal workings.

First we will generate a series of ``seed inputs'' for both AFL and our extended Superion which are accepted by the target programs and generate expected behavior.
Then we will then allow both fuzzing programs to mutate these seed inputs \cite{Seed} in order to probe for unexpected behavior.
During the initial calibration of of both AFL and Superion we will manually monitor progress and adapt the seeds as needed to ensure that they effectively probing the target programs.
Our target programs will be a suite of open source YAML processing libraries.

We will record each unique defect detected by both AFL and Superion during the fuzzing process.
We will take care to give both programs comparable CPU time on the target programs, to ensure that neither program is given an ``unfair'' advantage in searching for defects.
At the end of the experiment we will construct a comparative analysis on the fuzzing efficacy of our extended Superion compared to AFL.
Success of the project can easily be detected if out extended Superion detects more defects than AFL in the target programs.

Once one or more minimal triggering YAML inputs have been discovered, we will begin a process of debugging the YAML processing libraries to locate the source of the defect.
This is possible due to our selected YAML libraries being open source projects.
The process of debugging the discovered unexpected behavior will give us insight into the nature of the defect.
We intend to, if possible within the time constraints of the semester, to patch and submit pull requests correcting the discovered defects.
This final goal of patching discovered defects, is desirable to deepen our understand, but is not critical to the project, as the focus is on the experiment of improving fuzzing efficacy for YAML inputs.

The team expects to use their personal, commodity computer hardware to carry out this project.
However, should hardware constraints be discovered or it is determined to be beneficial for the project, the team members will have access to the DETER computing cluster at Hunter College.
Additionally, we can attempt to use Hunter's research credits on AWS.
Either way, we hope to reach a point of automation in the project where paralleization on a cluster is achievable, but can cope with commodity hardware.


\section*{Anticipated Results}
\label{results}

We expect that it is more efficient to test targets with structured input rather than with just simple random keywords from ``generic'' fuzzing.
Targeting YAML parsers, we expect our extended Superion fuzzer to efficiently find higher quantity and richer quality defects.
We will compare our extended fuzzer with general AFL over multiple YAML parsers, and see how our improvement on Superion performs better under which specific circumstances.
For every non-trivial defect, we run a root cause analysis to determine the source of each defect.
In case we find meaningful defects on targeted parsers, we also expect to author a patch to correct each defect.

In the event that the above results come ahead of schedule, we intend to extend our methodologies to common continuous integration (CI) services which use YAML as configuration files.
Each of our selected service have a method for locally testing your build.
For obvious ethical reasons we will not be fuzzing the live services, but rather the replicated services on our local machines.
We anticipate that these service may have vulnerabilities in mishandling configuration files which our extended Superion fuzzer may uncover.
We omitted these fuzzing targets from our core proposal, as we are unsure of the feasibility in creating an adapter to connect both AFL and our extended Superion to the local CI instances along with some of the targets being closed source.


\section*{Division of Labor}

Each member participate in extending Superion according to their abilities.
Furthermore, each member will use AFL and Superion to fuzz out target programs.
As defects are discovered, one or more group members may be diverted from actively guiding the fuzzing efforts to debugging the target program and performing root cause analysis of the source code to identify, classify, and correct the defect.
In general, the processes of authoring reports, completing literature review, preparing presentations, and presenting will be shared by all team members.


\section*{Timeline}

The project timeline is partially defined by the course syllabus where deadline are concerned and partially team defined where the syllabus does not give guidance.
The team has collaboratively discussed and drafted a tentative timeline of the project based on our assumptions of progress and integrated this with the deliverable deadlines laid out in the course syllabus. The current, tentative project timeline is as follows:

\begin{enumerate}[label={}]
	\item \texttt{2021-08-29:} Form team and brainstorm project ideas
	\item \texttt{2021-09-05:} \textbf{Project Proposal due}
	\item \texttt{2021-09-12:} Revise and resubmit proposal
	\item \texttt{2021-09-19:} Begin modifying Superion to generate YAML
	\item \texttt{2021-09-26:} Complete MVP of modified Superion which generates YAML
	\item \texttt{2021-10-03:} Have AFL \& Superion target YAML parsing libraries
	\item \texttt{2021-10-10:} \textbf{Midterm project presentations due} \hfill (Show fuzzing YAML output)
	\item \texttt{2021-10-17:} \textbf{Midterm project reports due} \hfill (Tune fuzzing instrumentation)
	\item \texttt{2021-10-24:} Tune AFL/Superion instrumentation 
	\item \texttt{2021-10-31:} Parallelize fuzzing \hfill (DETER/AWS)
	\item \texttt{2021-11-07:} Root cause analysis of library source code
	\item \texttt{2021-11-14:} Patch any applicable defects in YAML libraries
	\item \texttt{2021-11-21:} Start finalizing final draft
	\item \texttt{2021-11-28:} Start project report final draft \& final presentation
	\item \texttt{2021-12-05:} \textbf{Final project presentations due}
	\item \texttt{2021-12-12:} \textbf{Final project reports due 5:35 pm}
\end{enumerate}


\clearpage
\bibliographystyle{acm}
\bibliography{project-proposal}

\end{document}
